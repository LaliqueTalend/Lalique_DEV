// ============================================================================
//
// Copyright (C) 2018 LALIQUE SA - 
//
// ============================================================================
package routines;

import java.math.BigDecimal;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
//import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
//import java.util.Locale;

/*
 * user specification: the function's comment should contain keys as follows: 1. write about the function's comment.but
 * it must be before the "{talendTypes}" key.
 * 
 * 2. {talendTypes} 's value must be talend Type, it is required . its value should be one of: String, char | Character,
 * long | Long, int | Integer, boolean | Boolean, byte | Byte, Date, double | Double, float | Float, Object, short |
 * Short
 * 
 * 3. {Category} define a category for the Function. it is required. its value is user-defined .
 * 
 * 4. {param} 's format is: {param} <type>[(<default value or closed list values>)] <name>[ : <comment>]
 * 
 * <type> 's value should be one of: string, int, list, double, object, boolean, long, char, date. <name>'s value is the
 * Function's parameter name. the {param} is optional. so if you the Function without the parameters. the {param} don't
 * added. you can have many parameters for the Function.
 * 
 * 5. {example} gives a example for the Function. it is optional.
 */
public class JDE {

	/** Renvoie la quantité prévue d'une opération selon type d'OF
	 * 
     * {TalendTypes} String
     * 
     * {Category} Lalique Defined
	 */
	public static float getPlannedQuantity(String WOType,float standardQty,float declaredQty)
	{
		if(WOType == "F" && declaredQty != 0) {
			return declaredQty;
		}else {
			return standardQty;
		}
	}
	
	/**
     * Convertit une valeur de type BigDecimal en valeur de type Double
     * 
     * @param value : <code>BigDecimal</code> valeur à convertir.
     * @return valeur de type Double
     * @author Philippe BONGARD (24/04/2020)
     * @TalendInfos
     * 
     * {TalendTypes} Double
     * 
     * {Category} Lalique Defined
     * 
     * {param} BigDecimal value : <code>BigDecimal</code> valeur à convertir.
     */
    public static Double cnvDouble(BigDecimal value)
    {
	    if(value == null)
	    {
	    	return 0d;
	    }
	    else
	    {
	    	return value.doubleValue();
	    }
    }
    
    /**
     * Convertit une valeur de type BigDecimal en valeur de type Float
     * 
     * @param value : <code>BigDecimal</code> valeur à convertir.
     * @return valeur de type Float
     * @author Philippe BONGARD (24/04/2020)
     * @TalendInfos
     * 
     * {TalendTypes} float
     * 
     * {Category} Lalique Defined
     * 
     * {param} BigDecimal value : <code>BigDecimal</code> valeur à convertir.
     */
    public static float cnvFloat(BigDecimal value)
    {
	    if(value == null)
	    {
	    	return 0f;
	    }
	    else
	    {
	    	return value.floatValue();
	    }
    }
    
    /**
     * Convertit une valeur de type BigDecimal en valeur de type Integer
     * 
     * @param value : <code>BigDecimal</code> valeur à convertir.
     * @return valeur de type Integer
     * @author Philippe BONGARD (24/04/2020)
     * @TalendInfos
     * 
     * {TalendTypes} int
     * 
     * {Category} Lalique Defined
     * 
     * {param} BigDecimal value : valeur a convertir.
     */
    public static int cnvInt(BigDecimal value)
    {
	    if(value == null)
	    {
	    	return 0;
	    }
	    else
	    {
	    	return value.intValue();
	    }
    }
    
	/**
     * Renvoie un nombre sous forme d'une chaîne de caractères formatés.
     * </br><b>Exemple :</b> Afficher le nombre 1234.567 au format "#,##0.00" en utilisant le format US<pre>    <code>cnvString(1234.567, "#,##0.00", true)</code> --> 1,234.57</pre>
     * 
     * @param value : <code>double</code> - valeur à formater.
     * @param pattern : <code>String</code> - format de nombre à appliquer (indiqué au format US ex : #,##0.00").
     * @param formatUS : <code>boolean</code> - appliquer le format US (décimale = point).
     * @return Nombre formaté au format String
     * @author Philippe BONGARD (07/07/2020)
     * @TalendInfos
     * 
     * {TalendTypes} String
     * 
     * {Category} Lalique Defined
     * 
     * {param} double nombre : nombre a formater.
     * {param} String format : format a utiliser.
     * {param} boolean formatUS : Utiliser le format US.
     */
	public static String cnvString(double value, String pattern, boolean formatUS)
	{
//		NumberFormat nf = NumberFormat.getInstance(Locale inLocale);
		DecimalFormat dfmt = new DecimalFormat(pattern);
		if (formatUS) {
//			nf = NumberFormat.getInstance(Locale.US);
			DecimalFormatSymbols dfs = new DecimalFormatSymbols();
			dfs.setDecimalSeparator('.');
			dfs.setGroupingSeparator(',');
			dfmt.setDecimalFormatSymbols(dfs);
		}
			else {
		}
		return dfmt.format(value);
//		return nf.format(value);
	}

	/**
     * Renvoie un nombre sous forme d'une chaîne de caractères formatés.
     * </br><b>Exemple :</b> Afficher le nombre 123456.789 au format "#,##0.00"<pre>    <code>cnvString(123456.789, "#,##0.00")</code> --> 123 456,79</pre>
     * 
     * @param value : <code>double</code> - valeur à formater.
     * @param pattern : <code>String</code> - format de nombre à appliquer (format US ex : #,##0.00").
     * @return Nombre formaté au format local (Français)
     * @author Philippe BONGARD (07/07/2020)
     * @TalendInfos
     * 
     * {TalendTypes} String
     * 
     * {Category} Lalique Defined
     * 
     * {param} double nombre
     * {param} String format
     */
	public static String cnvString(double value, String pattern)
	{
		DecimalFormat dfmt = new DecimalFormat(pattern);
		return dfmt.format(value);
	}
	
    /**
     * Renvoie une date au format Julian JDE (integer).
     * </br><b>Exemple :</b> Convertir la date 04/02/2020 en format Julian de JDE.<pre>    <code>convertFromJulian(04/02/2020)</code> --> 120035</pre>
     * 
     * @param date : <code>Date</code> - Date à convertir.
     * @return La date au format Julian (int)
     * @author Philippe BONGARD (24/04/2020)
     * @TalendInfos
     * 
     * {TalendTypes} Date
     * 
     * {Category} Lalique Defined
     * 
     * {param} Date date : <code>Date</code> - Date à convertir.
     */
    public static int convertToJulian(Date date) 
    {
    	SimpleDateFormat pFormat = new SimpleDateFormat("DDD");
    	Calendar pDate = Calendar.getInstance();
        pDate.setTime(date);
    	return Integer.parseInt(Integer.toString(pDate.get(Calendar.YEAR)-1900) + pFormat.format(date));
    }
    
    /**
     * Renvoie une date au format julien JDE convertie au format Date.
     * </br><b>Exemple :</b> Convertir le champ SZUPMJ de la table F4101 en date.<pre>    <code>convertFromJulian(F4101.SZUPMJ)</code></pre>
     * 
     * @param julianDate : <code>BigDecimal</code> date au format julien.
     * @return La date au format Date de Java
     * @author Philippe BONGARD (24/04/2020)
     * @TalendInfos
     * 
     * {TalendTypes} Date
     * 
     * {Category} Lalique Defined
     * 
     * {param} BigDecimal julianDate : <code>BigDecimal</code> date au format julien.
     */
    public static Date convertFromJulian(BigDecimal julianDate) 
    {
	    if(julianDate == null)
	    {
	    	return convertFromJulian(0);
	    }
	    else
	    {
	    	return convertFromJulian(julianDate.intValue());
	    }
    }

    /**
     * Renvoie une date au format julien JDE convertie au format Date.
     * </br><b>Exemple :</b> Convertir la valeur 120035 en date.<pre>    <code>convertFromJulian(120035)</code> --> 04/02/2020</pre>
     * 
     * @param julianDate : <code>int</code> date au format julien.
     * @return La date au format Date de Java (Oracle)
     * @author Philippe BONGARD (24/04/2020)
     * @TalendInfos
     * 
     * {TalendTypes} Date
     * 
     * {Category} Lalique Defined
     * 
     * {param} int julianDate : <code>int</code> date au format julien.
     */
    public static Date convertFromJulian(int julianDate) 
    {
	    Calendar pDate = Calendar.getInstance();
	    pDate.set(0, 0, 1); //01/01/1970
	    
	    if(julianDate != 0) {
			 int pYear, pDays;
			 pYear = Math.round(julianDate / 1000) + 1900; 
			 pDays = Math.floorMod(julianDate, 1000);

		     pDate.set(pYear, Calendar.JANUARY, 0);
		     pDate.add(Calendar.DAY_OF_YEAR, pDays);
	    }
	    return pDate.getTime();
    }

    /**
     * convertToJulian: return date converted in Julian format
     * 
     * {TalendTypes} int
     * 
     * {Category} Lalique Defined
     * 
     * {param} string("theDate") input: The string need to be printed.
     * 
     * {example} helloExemple("world") # hello world !.
     */
    public static int convertToJulian(String theDate)
    {
	    /* Date: ddmmyyyy*/
	    int resultJulian = 0;
	    if(theDate.length() > 0)
	    {
			 String dayS, monthS, yearS;
			 /*Days of month*/
			 int[] monthValues = {31,28,31,30,31,30,31,31,30,31,30,31};
			 dayS = theDate.substring(0,2);
			 monthS = theDate.substring(2, 4);
			 yearS = theDate.substring(4, 8);
			
			 /*Convert to Integer*/
		     int day = Integer.valueOf(dayS);
		     int month = Integer.valueOf(monthS);
		     int year = Integer.valueOf(yearS); 
			
			 //Leap year check
			 if(year % 4 == 0)
			 {
				  monthValues[1] = 29;    
			 }
			
			 //Start building Julian date
			 String julianDate = "1";
			 //last two digit of year: 20xx ==> xx
			 julianDate += yearS.substring(2,4);
			 int julianDays = 0;
			 for (int i=0; i < month-1; i++)
			 {
			    julianDays += monthValues[i];
			 }
			 julianDays += day;
			 //Check size of days number
			 if( julianDays < 100)
			 {
			    julianDate += "0";
			 }
			 if( julianDays < 10)
			 {
			    julianDate += "0";
	         }
	         julianDate += String.valueOf(julianDays);
		     resultJulian =  Integer.valueOf(julianDate);    
	    }
	    return resultJulian;
    }

	/**
	 * Arrondi à l'int le plus proche de l'argument en paramètre.
	 *
	 * {talendTypes} int | Int
	 *
	 * {Category} 
	 *
	 * {param} float(3.14f)
	 *
	 * {example} roundDown(3.14f)
	 */
  	public static int roundDown(float a) {
  		// this check for NaN, from JLS 15.21.1, saves a method call
  		float incrn = -0.000000000001f;
  		if (a != a)
  			return 0;
  		return (int) Math.floor(a < 0 ? a + incrn : a );
}


  	/**
  	 * Arrondi au float le plus proche de l'argument en paramètre.
  	 *
  	 * {talendTypes} long | Long
  	 *
  	 * {Category} 
  	 *
  	 * {param} double(3.14)
  	 *
  	 * {example} roundDown(3.14)
  	 */
  	public static long roundDown(double a) {
  		// this check for NaN, from JLS 15.21.1, saves a method call
  		double incrn = -0.000000000001d;
  		if (a != a)
  			return 0;
  		return (long) Math.floor(a < 0 ? a + incrn : a );
}

    /**
     * Arrondi à l'int le plus proche de l'argument en paramètre.
     *
     * {talendTypes} int | Int
     *
     * {Category} 
     *
     * {param} float(3.14f)
     *
     * {example} round(3.14f)
     */
      public static int round(float a) {
      // this check for NaN, from JLS 15.21.1, saves a method call
            if (a != a)
           return 0;
        return (int) Math.round(Math.abs(a)) * (a < 0 ? -1 : 1 );
    }

   
    /**
     * Arrondi au float le plus proche de l'argument en paramètre.
     *
     * {talendTypes} long | Long
     *
     * {Category} 
     *
     * {param} double(3.14)
     *
     * {example} round(3.14)
     */
    public static long round(double a) {
      // this check for NaN, from JLS 15.21.1, saves a method call
      if (a != a)
           return 0;
        return (long) Math.round(Math.abs(a)) * (a < 0 ? -1 : 1 );
    }

	/** Indique si l'opération doit être envoyée à Quartis
     * </br><b>Exemple :</b> Déterminer si l'opération d'un OF Verre Froid doit être envoyée à Quartis (où SYTYPS='F', MCRP14='F  ', WLBFPF=' ').
     * <pre>    <code>isOpeQuartis(SYTYPS,MCRP14,WLBFPF)</code> --> false</pre>
     * 
     * @param TYPS : <code>String</code> - Type d'OF.
     * @param RP14 : <code>String</code> - Indicateur de poste de charge fictif ou de réparation.
     * @param BFPF : <code>String</code> - Point de comptage de l'opération.
     * @return true si opération à envoyer, sinon false.
     * @author Philippe BONGARD (09/07/2020)
     * @TalendInfos
     * 
     * {TalendTypes} boolean
     * 
     * {Category} Lalique Defined
	 *
	 * {param} String("") TYPS : Type d'OF
	 * {param} String("") RP14 : Categorie CC
	 * {param} String("") BFPF : Point de comptage
	 */
	public static boolean isOpeQuartis(String TYPS, String RP14, String BFPF)
	{
		Boolean myVal = true;
		if(RP14.trim().equals("F")) {
			myVal=false;
		}
		if(TYPS.trim().equals("R") == false) {
			if((RP14.trim().equals("R") || RP14.trim().equals("Y")) && BFPF.trim().equals("0")) {
				myVal=false;
			}
		}
		return myVal;
	}
	
}